# 21道字节跳动7天挑战题

## LC 105. 从前序与中序遍历序列构造二叉树

```cpp
class Solution {
    unordered_map<int, int>index;
public:
    TreeNode *mybuild(const vector<int>&preorder, vector<int>&inorder, int pl, int pr, int il, int ir) {
        if(pl > pr) return nullptr;
        int proot = pl;
        int iroot = index[preorder[proot]];
        TreeNode *root = new TreeNode(preorder[proot]);
        int size = iroot - il;
        root->left = mybuild(preorder, inorder, pl + 1, proot + size, il, iroot - 1);
        root->right = mybuild(preorder, inorder, proot + size + 1, pr, iroot + 1, ir);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for(int i = 0; i < n; i++) {
            index[inorder[i]] = i;
        }
        return mybuild(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

## LC 172. 阶乘后的零

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        int sum = 0;
        while(n) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
};
```

## </>古生物血缘远近判定

```cpp
#include<iostream>
#include<string>
using namespace std;
int dp[105][105];
int main() {
    string a;
    string b;
    char ch;
    int w = 0;
    while(cin >> ch) {
        if(w == 1) {
            b += ch;
        }
        if(w == 0 && ch != ',') {
            a += ch;
        }
        if(ch == ',') {
            w = 1;
        }
    }
    int lena = a.size();
    int lenb = b.size();
    for(int i = 1; i <= lena; i++) {
        dp[i][0] = i;
    }
    for(int i = 1; i <= lenb; i++) {
        dp[0][i] = i;
    }
    for(int i = 1; i <= lena; i++) {
        for(int j = 1; j <= lenb; j++) {
            if(a[i - 1] == b[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    cout << dp[lena][lenb] << endl;
    return 0;
}
```

## LC 85. 最大矩形

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& mat) {
        if(mat.empty()) return 0;
        int n = mat.size();
        int m = mat[0].size();
        vector<int>h(m + 1, 0);
        int mmax = 0;
        int hi, width;
        for(int i = 0; i < n; i++) {
            mat[i].push_back('0');
            stack<int>s;
            for(int j = 0; j <= m; j++) {
                h[j] = mat[i][j] == '1' ? h[j] + 1 : 0;
                while(!s.empty() && h[s.top()] > h[j]) {
                    hi = h[s.top()];
                    s.pop();
                    width = s.empty() ? j : j - s.top() - 1;
                    mmax = max(mmax, width * hi);
                }
                s.push(j);
            }
        }
        return mmax;
    }
};
```

## LC 1739. 放置盒子

```cpp
class Solution {
public:
    int minimumBoxes(int n) {
        int sum = 0, k = 1;
        while(sum + k * (k + 1) / 2 <= n) {
            sum += k * (k + 1) / 2;
            k ++;
        }
        k--;
        int res = k * (k + 1) / 2;
        k = 1;
        while(sum < n) {
            sum += k;
            k++;
            res++;
        }
        return res;
    }
};
```

