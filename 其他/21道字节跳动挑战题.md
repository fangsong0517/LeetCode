# 21道字节跳动7天挑战题

## LC 105. 从前序与中序遍历序列构造二叉树

![image-20210202222113519](http://test-fangsong-imgsubmit.oss-cn-beijing.aliyuncs.com/img/image-20210202222113519.png)

```cpp
class Solution {
    unordered_map<int, int>index;
public:
    TreeNode *mybuild(const vector<int>&preorder, vector<int>&inorder, int pl, int pr, int il, int ir) {
        if(pl > pr) return nullptr;
        int proot = pl;//前序的根节点
        int iroot = index[preorder[proot]];//获取在中序中的位置
        TreeNode *root = new TreeNode(preorder[proot]);//根节点
        int size = iroot - il;//左子树个数
        root->left = mybuild(preorder, inorder, pl + 1, proot + size, il, iroot - 1);//左子树
        root->right = mybuild(preorder, inorder, proot + size + 1, pr, iroot + 1, ir);//右子树
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for(int i = 0; i < n; i++) {
            index[inorder[i]] = i;//构建哈希
        }
        return mybuild(preorder, inorder, 0, n - 1, 0, n - 1);
    }
};
```

## LC 172. 阶乘后的零

例如：10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1

​			5 * 2可以共享一个0，10贡献一个0，当有一对5和2就能共享一个0

​			末尾的“0”的个数，可以转换为计算其因式分解中“5”的个数。

```cpp
class Solution {
public:
    int trailingZeroes(int n) {
        int sum = 0;
        while(n) {
            sum += n / 5;
            n /= 5;
        }
        return sum;
    }
};
```

## </>古生物血缘远近判定（编辑距离）

```cpp
#include<iostream>
#include<string>
using namespace std;
int dp[105][105];
int main() {
    string a;
    string b;
    char ch;
    int w = 0;
    while(cin >> ch) {
        if(w == 1) {
            b += ch;
        }
        if(w == 0 && ch != ',') {
            a += ch;
        }
        if(ch == ',') {
            w = 1;
        }
    }
    int lena = a.size();
    int lenb = b.size();
    for(int i = 1; i <= lena; i++) {
        dp[i][0] = i;
    }
    for(int i = 1; i <= lenb; i++) {
        dp[0][i] = i;
    }
    for(int i = 1; i <= lena; i++) {
        for(int j = 1; j <= lenb; j++) {
            if(a[i - 1] == b[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = min(min(dp[i - 1][j], dp[i][j - 1]), dp[i - 1][j - 1]) + 1;
            }
        }
    }
    cout << dp[lena][lenb] << endl;
    return 0;
}
```

## LC 85. 最大矩形（单调栈）

```cpp
class Solution {
public:
    int maximalRectangle(vector<vector<char>>& mat) {
        if(mat.empty()) return 0;
        int n = mat.size();
        int m = mat[0].size();
        vector<int>h(m + 1, 0);
        int mmax = 0;
        int hi, width;
        for(int i = 0; i < n; i++) {
            mat[i].push_back('0');
            stack<int>s;
            for(int j = 0; j <= m; j++) {
                h[j] = mat[i][j] == '1' ? h[j] + 1 : 0;
                while(!s.empty() && h[s.top()] > h[j]) {
                    hi = h[s.top()];
                    s.pop();
                    width = s.empty() ? j : j - s.top() - 1;
                    mmax = max(mmax, width * hi);
                }
                s.push(j);
            }
        }
        return mmax;
    }
};
```

## LC 1739. 放置盒子

```cpp
class Solution {
public:
    int minimumBoxes(int n) {
        int sum = 0, k = 1;
        while(sum + k * (k + 1) / 2 <= n) {
            sum += k * (k + 1) / 2;
            k ++;
        }
        k--;
        int res = k * (k + 1) / 2;
        k = 1;
        while(sum < n) {
            sum += k;
            k++;
            res++;
        }
        return res;
    }
};
```

## </>化学公式解析

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<algorithm>
#include<map>
#include<vector>
#include<set>
#include<stack>
using namespace std;

string countOfAtoms(string formula) {
    string res;
    map<string,int> m;//记录字符串有几个
    stack<int> sta;//栈
    sta.push(1);
    int t = formula.size()-1,l = t+1;
    for(int i = formula.size()-1; i >= 0; --i){//从后往前
        if(formula[i] >= '0' && formula[i] <= '9'){//如果为数字那么l记录最后一个数字位置
            l = i;
            continue;
        }
        else{//不是数字的时候
            if(formula[i] == ')' || formula[i] == ']'){
                if(t != i) {//最后不是)]，例如]4就是这个情况，此时i走到]
                    int p = stoi(formula.substr(i+1,t-i));//从i + 1,往后切出t - i个
                    sta.push(sta.top()*p);//将数字入栈
                }
                else sta.push(sta.top());//最后是字母,例如H2O,O就是最后一个，说明前面字符串有sta.top个
                l = i;//l记录)或]位置
            }
            else if(formula[i] == '(' || formula[i] == '['){//如果([时拼接完了，可以出栈了
                sta.pop();
                l = i;
            }
            else{//字母的时候
                if(i == formula.size()-1 || formula[i+1] < 'a' || formula[i+1] > 'z'){//最后的时候
                    if(t != i) {
                        int p = stoi(formula.substr(i+1,t-i));
                        sta.push(sta.top()*p);
                    }
                    else sta.push(sta.top());
                }
                if(formula[i] >= 'A' && formula[i] <= 'Z'){
                    m[formula.substr(i,l-i)] += sta.top();//字符有多少个
                    sta.pop();
                    l = i;
                }
            }
            t = i-1;
        }
    }
    for(auto& x:m){
        res.append(x.first);
        if(x.second >= 1) res.append(to_string(x.second));
    }
    return res;
}
int main() {
    string s;
    cin >> s;
    cout << countOfAtoms(s) << endl;
    return 0;
}
```

## LC 1675. 数组的最小偏移量

```cpp
class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
        priority_queue<int>pq;
        int min_n = INT_MAX;//时刻记录一个最小值
        for(auto n : nums) {//可以先将所有的奇数乘上2
            if(n % 2) {
                n *= 2;
            }
            pq.push(n);
            min_n = min(min_n, n);//最小的值
        }
        int res = INT_MAX;
        while(pq.top() % 2 == 0) {//最大是偶数的时候，可以除以2缩小差距
            int t = pq.top() / 2;
            pq.pop();
            pq.push(t);
            min_n = min(min_n, t);
            res = min(res, pq.top() - min_n);
        }//最大是奇数的时候不能往上乘法变大啊
        return res;
    }
};
```

## LC 753. 破解保险箱

```cpp
class Solution {
public:
    string crackSafe(int n, int k) {
        string ans(n - 1, '0');
        int p = pow(k, n);
        unordered_map<string, int>m;
        for(int i = 0; i < p; i++) {
            ans.push_back('0' + k - ++m[ans.substr(i, n - 1)]);
        }
        return ans;
    }
};
```

## LC 22. 括号生成

```cpp
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string>ret;
        dfs(ret, "", 0, 0, n);
        return ret;
    }
    void dfs(vector<string>&ret, string str, int l, int r, int n) {
        if(l > n || r > n || r > l)return;
        //如果(()))右括号多于左括号就不行了
        if(l == n && r == n) {
            ret.push_back(str);
            return ;
        }
        dfs(ret, str + '(', l + 1, r, n);
        dfs(ret, str + ')', l, r + 1, n);
        return;
    }
};
```

## </>数组组成最大数

```cpp
#include<iostream>  
#include<algorithm>
#include<sstream>        //istringstream 必须包含这个头文件
#include<string>  
using namespace std;  
bool cmp(int a, int b) {
    string num1 = to_string(a) + to_string(b);
    string num2 = to_string(b) + to_string(a);
    return num1 > num2;
}
int main() {  
    int num[1500];
    int index = 0;
    while(1) {
        char w;
        int s;
        cin >> w;
        if(w == ']')break;
        cin >> s;
        num[index++] = s;   
    }
    sort(num, num + index, cmp);
    for(int i = 0; i < index; i++) {
        cout << num[i];
    }
    cout << endl;
    return 0;
}
```

## LC 60. 排列序列（逆康托展开）

```cpp
class Solution {
public:
    string getPermutation(int n, int k) {
        const int factor[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
        string str;
        vector<int>v;
        k--;
        for(int i = 1; i <= n; i++) {
            v.push_back(i);
        }
        for(int i = n; i >= 1; i--) {
            int r = k % factor[i - 1];
            int t = k / factor[i - 1];
            k = r;
            sort(v.begin(), v.end());
            str += to_string(v[t]);
            v.erase(v.begin() + t);
        }
        return str;
    }
};
```

1. 康拓展开

   >在（1，2，3，4，5）5个数的排列组合中，计算 34152的康托展开值。
   >带入上面的公式
   >
   >- X = 2 * 4! + 2 * 3! + 0 * 2! + 1 * 1! + 0 * 0!
   >  =>X = 61

   ```cpp
   //返回数组a中当下顺序的康拖映射
   int cantor(int *a,int n)
   {
   	int ans=0;
   	for(int i=0;i<n;i++)
   	{
   		int x=0;int c=1,m=1;//c记录后面的阶乘
   		for(int j=i+1;j<n;j++)
   		{
   			if(a[j]<a[i])x++;
   			m*=c;c++;
   		}
   		ans+=x*m;
   	}
   	return ans;
   }
   ```

2. 逆康拓展开

   >- 前面已经说到康拖展开是从序列到自然数的映射且是可逆的，那么逆康拖展开便是从自然数到序列的映射
   >
   >**列 ：**
   >在（1，2，3，4，5) 给出61可以算出起排列组合为34152
   >具体过程如下：
   >用 61 / 4! = 2余13，说明 ,说明比首位小的数有2个，所以首位为3。
   >用 13 / 3! = 2余1，说明 ，说明在第二位之后小于第二位的数有2个，所以第二位为4。
   >用 1 / 2! = 0余1，说明 ，说明在第三位之后没有小于第三位的数，所以第三位为1。
   >用 1 / 1! = 1余0，说明 ，说明在第二位之后小于第四位的数有1个，所以第四位为5。

   ```cpp
   static const int FAC[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};   // 阶乘
     
   //康托展开逆运算
   void decantor(int x, int n)
   {
       vector<int> v;  // 存放当前可选数
       vector<int> a;  // 所求排列组合
       for(int i=1;i<=n;i++)
           v.push_back(i);
       for(int i=n;i>=1;i--)
       {
           int r = x % FAC[i-1];
           int t = x / FAC[i-1];
           x = r;
           sort(v.begin(),v.end());// 从小到大排序
           a.push_back(v[t]);      // 剩余数里第t+1个数为当前位
           v.erase(v.begin()+t);   // 移除选做当前位的数
       }
   }
   ```




## LC 468. 验证 IP 地址

```cpp
class Solution {
public:
    string validIPAddress(string IP) {
        if(IP.find('.') != string::npos && isIPv4(IP)) {
            return "IPv4";
        }
        if(IP.find(':') != string::npos && isIPv6(IP)) {
            return "IPv6";
        }
        return "Neither";
    }
    void split(string &IP, char &ch, vector<string>&part) {
        string p;
        for(int i = 0; i < IP.size(); i++) {
            if((IP[i] == ch || i == IP.size() - 1)) {
                if(i == IP.size() - 1) p += IP[i];
                part.push_back(p);
                p = "";
            } else {
                p += IP[i];
            }
        }
    }
    bool isIPv4(string &IP) {
        char ch = '.';
        vector<string>part;
        split(IP, ch, part);
        if(part.size() != 4) return false;
        for(auto p : part) {
            int s = 0;
            if(p == "" || (p[0] == '0' && p.size() != 1))return false;
            for(int i = 0; i < p.size(); i++) {
                if(!isdigit(p[i])) return false;
                s = s * 10 + p[i] - '0';
                if(s > 255) return false;
            }
        }
        return true;
    }
    bool isIPv6(string &IP) {
        char ch = ':';
        vector<string>part;
        split(IP, ch, part);
        if(part.size() != 8) {
            return false;
        }
        for(auto p : part) {
            if(p.size() == 0 || p.size() > 4) {
                return false;
            }
            for(int i = 0; i < p.size(); i++) {
                if(!(isdigit(p[i]) || (tolower(p[i]) >= 'a' && tolower(p[i]) <= 'f'))) {
                    return false;
                }
            }
        }
        return true;
    }
};
```

## LC 100. 相同的树

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(p == NULL && q == NULL) return true;
        if(p == NULL || q == NULL) return false;
        return (p->val == q->val) && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
    }
};
```

## LC 971. 翻转二叉树以匹配先序遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int i = 0;
    bool can = true;
    vector<int>ans;
public:
    vector<int> flipMatchVoyage(TreeNode* root, vector<int>& voyage) {
        dfs(root, voyage);
        if(!can) return {-1};
        return ans;
    }
    void dfs(TreeNode *root, vector<int>&voyage) {
        if(!root || !can) return;
        if(root->val == voyage[i]) {
            i++;
            if(root->left && root->left->val == voyage[i]) {
                dfs(root->left, voyage);
                dfs(root->right, voyage);
            } else if(root->right && root->right->val == voyage[i]) {
                if(root->left) {
                    ans.push_back(root->val);
                }
                dfs(root->right, voyage);
                dfs(root->left, voyage);
            } else if(root->left || root->right) {
                can = false;
            }
        } else {
            can = false;
        }
    }
};
```

## LC 121. 买卖股票的最佳时机

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() <= 1) return 0;
        int mmax = 0;
        int mmin = prices[0];
        for(int i = 1; i < prices.size(); i++) {
            mmax = max(mmax, prices[i] - mmin);
            mmin = min(mmin, prices[i]);
        }
        return mmax;
    }
};
```

## LC 72. 编辑距离

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        int len1 = word1.size();
        int len2 = word2.size();
        vector<vector<int>>dp(len1 + 1, vector<int>(len2 + 1, 0));
        for(int i = 1; i <= len1; i++) {
            dp[i][0] = i;
        }
        for(int j = 1; j <= len2; j++) {
            dp[0][j] = j;
        }
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                if(word1[i - 1] == word2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;
                }
            }
        }
        return dp[len1][len2];
    }
};
```

